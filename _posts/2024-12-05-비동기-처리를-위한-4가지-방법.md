---
layout: post
date: 2024-12-05
title: "비동기 처리를 위한 4가지 방법"
tags: [Tips, ]
categories: [Swift, ]
---



#### 클로저, RxSwift, Combine, Async 4가지 샘플 코드



### Closure 클로저



{% raw %}
```swift
   import Foundation
   
    static func fetchTodos(page: Int = 1, completion: @escaping (Result<BaseListResponse<Todo>, ApiError>) -> Void ) {
       
        let urlString = baseURL + "/todos" + "?page=\(page)"
        
        guard let url = URL(string: urlString) else {
            return completion(.failure(ApiError.notAllowedUrl))
        }
        
        var urlRequest = URLRequest(url: url)
        urlRequest.httpMethod = "GET"
        urlRequest.addValue("application/json", forHTTPHeaderField: "accept")
     
        URLSession.shared.dataTask(with: urlRequest) { data, response, err in
     
            if let error = err {
                return completion(.failure(ApiError.unknown(error)))
            }
            
            guard let httpResponse = response as? HTTPURLResponse else {
                print("bad status code")
                return completion(.failure(ApiError.unknown(nil)))
            }
            
            switch httpResponse.statusCode {
            case 401:
                return completion(.failure(ApiError.unauthorized))
            default: print("default")
            }
            
            if !(200...299).contains(httpResponse.statusCode) {
                return completion(.failure(ApiError.badStatus(code: httpResponse.statusCode)))
            }
            
            if let jsonData = data {
                do {
                    let listResponse = try JSONDecoder().decode(BaseListResponse<Todo>.self, from: jsonData)
                    guard let todos = listResponse.data,
                          !todos.isEmpty else {
                        return completion(.failure(ApiError.noContent))
                    }
                    completion(.success(listResponse))
                } catch {
                    // decoding error
                    completion(.failure(.decodingError))
                }
            }
        }.resume()
    }
```
{% endraw %}




### RxSwift



{% raw %}
```swift
import Foundation
import RxCocoa
import RxSwift

static func fetchTodosWithObservableResult(page: Int = 1) -> Observable<
        Result<BaseListResponse<Todo>, ApiError>
    > {
     
        let urlString = baseURL + "/todos" + "?page=\(page)"
        guard let url = URL(string: urlString) else {
            return Observable.just(.failure(ApiError.notAllowedUrl))
        }
        
        var urlRequest = URLRequest(url: url)
        urlRequest.httpMethod = "GET"
        urlRequest.addValue("application/json", forHTTPHeaderField: "accept")
        
        return URLSession.shared.rx.response(request: urlRequest)
            .map({
                (response: HTTPURLResponse, data: Data) -> Result<BaseListResponse<Todo>, ApiError> in
       
                guard let httpResponse = response as? HTTPURLResponse else {
                    print("bad status code")
                    return .failure(ApiError.unknown(nil))
                }
                
                switch httpResponse.statusCode {
                case 401:
                    return .failure(ApiError.unauthorized)
                default: print("default")
                }
                
                if !(200...299).contains(httpResponse.statusCode) {
                    return .failure(
                        ApiError.badStatus(code: httpResponse.statusCode))
                }
                
                do {
                    let listResponse = try JSONDecoder().decode(BaseListResponse<Todo>.self, from: data)
                    guard let todos = listResponse.data,
                          !todos.isEmpty
                    else {
                        return .failure(ApiError.noContent)
                    }
                    return .success(listResponse)
                    
                } catch {
                    // decoding error
                    return .failure(.decodingError)
                }
            })
    }
```
{% endraw %}




### Combine



{% raw %}
```swift
import Foundation
import MultipartForm
import RxCocoa
import RxSwift
import Combine
import CombineExt

/// 모든 할 일 목록 가져오기
    static func fetchTodosWithPublisherResult(page: Int = 1) -> AnyPublisher<
        Result<BaseListResponse<Todo>, ApiError>, Never> {
          
            let urlString = baseURL + "/todos" + "?page=\(page)"
            guard let url = URL(string: urlString) else {
                return Just(.failure(ApiError.notAllowedUrl)).eraseToAnyPublisher()
            }
            
            var urlRequest = URLRequest(url: url)
            urlRequest.httpMethod = "GET"
            urlRequest.addValue("application/json", forHTTPHeaderField: "accept")
            
            return URLSession.shared.dataTaskPublisher(for: urlRequest)
                .map({ (data: Data, response: URLResponse) -> Result<BaseListResponse<Todo>, ApiError> in
                
                    guard let httpResponse = response as? HTTPURLResponse else {
                        print("bad status code")
                        return .failure(ApiError.unknown(nil))
                    }
                    
                    switch httpResponse.statusCode {
                    case 401:
                        return .failure(ApiError.unauthorized)
                    default: print("default")
                    }
                    
                    if !(200...299).contains(httpResponse.statusCode) {
                        return .failure(
                            ApiError.badStatus(code: httpResponse.statusCode))
                    }
                    
                    do {
                    
                        let listResponse = try JSONDecoder().decode(BaseListResponse<Todo>.self, from: data)
                        guard let todos = listResponse.data,
                              !todos.isEmpty
                        else {
                            return .failure(ApiError.noContent)
                        }
                        return .success(listResponse)
                        
                    } catch {
                        // decoding error
                        return .failure(.decodingError)
                    }
                })
       
                .replaceError(with: .failure(ApiError.unknown(nil))) // (에러 -> 데이터로 변경)
                .eraseToAnyPublisher()
        }
```
{% endraw %}




### Async



{% raw %}
```swift
import Foundation
import MultipartForm
import RxCocoa
import RxSwift
import Combine
import CombineExt

static func fetchTodosWithAsyncResult(page: Int = 1) async -> Result<BaseListResponse<Todo>, ApiError> {
     
        let urlString = baseURL + "/todos" + "?page=\(page)"
        guard let url = URL(string: urlString) else {
            return .failure(ApiError.notAllowedUrl)
        }
        
        var urlRequest = URLRequest(url: url)
        urlRequest.httpMethod = "GET"
        urlRequest.addValue("application/json", forHTTPHeaderField: "accept")
        do {
            let (data, response) = try await URLSession.shared.data(for: urlRequest)
            
            guard let httpResponse = response as? HTTPURLResponse else {
                print("bad status code")
                return .failure(ApiError.unknown(nil))
            }
            
            switch httpResponse.statusCode {
            case 401:
                return .failure(ApiError.unauthorized)
            default: print("default")
            }
            
            if !(200...299).contains(httpResponse.statusCode) {
                return .failure(
                    ApiError.badStatus(code: httpResponse.statusCode))
            }
            
            let listResponse = try JSONDecoder().decode(BaseListResponse<Todo>.self, from: data)
            
            guard let todos = listResponse.data,
                  !todos.isEmpty
            else {
                return .failure(ApiError.noContent)
            }
            return .success(listResponse)
            
        } catch {
            if let _ = error as? DecodingError {
                return .failure(ApiError.decodingError)
            }else {
                return .failure(ApiError.unknown(error))
            }
        }
    }
```
{% endraw %}


