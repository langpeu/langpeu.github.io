---
layout: post
date: 2025-09-21
title: "2️⃣ WWDC 2025 -SwiftUI 7.0- iOS 26"
tags: [FoundationModels, streamResponse, ]
categories: [SwiftUI, ]
---



#### 1. FoundationModels (SDK)
(온디바이스 인텔리전스)


Xcode 26에는 이제 FoundationModels SDK가 포함되어, 온디바이스 인텔리전스 모델을 활용할 수 있습니다.
이 모델들은 디바이스 내에서 동작하기 때문에, 디바이스가 오프라인 상태여도 기능을 수행할 수 있습니다.
이제 이 새로운 SDK의 핵심적인 활용 사례들을 살펴보겠습니다.


⭐️ iPhone 15 이상 또는 M1 칩이 달린 iPad / Mac 이후 기종 만 지원됨 


+. streamResponse
코드 몇 줄만으로도 우리는 이 새로운 SDK를 이용해 AI 채팅을 만들 수 있습니다.
하지만 답변이 너무 오래 걸린다는 것을 눈치채셨나요?


네, 그 이유는 제가 한 번에 전체 결과를 요청하고 있기 때문입니다.
하지만 부분적인 반복 결과(Partial Iterative Results)를 받을 수 있는 방법이 있습니다.
이 방식은 요즘 AI 채팅에서 가장 흔히 사용되고 있죠.


![0](/assets/img/2025-09-21-2️⃣ WWDC-2025--SwiftUI-7.0--iOS-26.md/0.png)



{% raw %}
```swift
import FoundationModels

struct ContentView: View {
    @State private var prompt: String = ""
    @State private var answer: String = ""
    @State private var disableControls: Bool = false
    var body: some View {
        NavigationStack {
            ScrollView(.vertical) {
                Text(answer)
                    .frame(maxWidth: .infinity, alignment: .leading)
                    .multilineTextAlignment(.leading)
                    .padding(15)
            }
            .safeAreaBar(edge: .bottom) {
                HStack(spacing: 10) {
                    TextField("Prompt", text: $prompt)
                        .padding(.horizontal, 15)
                        .padding(.vertical, 10)
                        .glassEffect(.regular, in: .capsule)
                    
                    Button {
                        Task {
                            guard !prompt.isEmpty else { return }
                            
                            do {
                                let session = LanguageModelSession()
                                disableControls = true
                                
                                let response = session.streamResponse(to: prompt)
                                
                                
                                for try await chunk in response {
                                    self.answer = chunk.content
                                }
                                
                                disableControls = false
                            }catch {
                                disableControls = false
                                print(error.localizedDescription)
                            }
                        }
                        
                    } label: {
                        Image(systemName: "paperplane.fill")
                            .frame(width: 30, height: 30)
                    }
                    .buttonStyle(.glass)
                }
                .disabled(disableControls)
                .padding(25)
                
            }
            .navigationTitle("Foundataion Model")
        }
    }
}
```
{% endraw %}




#### 2.  **FoundationModels (@Generable)**


FoundationModels에는 @Generable 이라는 매크로가 포함되어 있으며, 이를 통해 LanguageModelSession이 지정된 모델을 위한 데이터를 생성할 수 있습니다.


이 예시에서는 Todo 라는 이름의 모델을 생성할 것입니다.


이 매크로를 사용하면, 언어 모델에게 무작위 할 일(todo) 목록을 생성하도록 요청할 수 있습니다.


비록 이것이 실질적인 사용 사례는 아닐 수 있지만, 다른 많은 시나리오에서 유용하게 활용될 수 있습니다!


+. @Guide()


이것은 LanguageModel에 이러한 속성을 채우는 데 필요한 컨텍스트를 제공합니다.
또한, @Generable에도 이러한 설명을 제공할 수 있습니다!


@Guide() 적용을 하면 아래 사진 처럼 Contenxt 가 @Guide(description: "칫솔질")에 따라 비슷한 형식으로 변경된다. 


![1](/assets/img/2025-09-21-2️⃣ WWDC-2025--SwiftUI-7.0--iOS-26.md/1.png)


![2](/assets/img/2025-09-21-2️⃣ WWDC-2025--SwiftUI-7.0--iOS-26.md/2.png)



{% raw %}
```swift
import SwiftUI
import FoundationModels

struct ContentView: View {
    @State private var todos: [Todo] = []
    @State private var isWriting: Bool = false
    var body: some View {
        NavigationStack {
            List {
                ForEach(todos) { todo in
                    Text(todo.task)
                }
            }
            .navigationTitle("Todo")
            .toolbar(content: {
                ToolbarItem(placement: .topBarTrailing) {
                    Button("", systemImage: "apple.intelligence") {
                        let propmt = "Create 10 todo list items in Korean"
                        Task {
                            do {
                                let session = LanguageModelSession()
                                let response = session.streamResponse(generating: [Todo].self) {
                                    propmt
                                }
                                
                                isWriting = true
                                for try await chunkTodos in response {
                                    self.todos = chunkTodos.content.compactMap({
                                        if let id = $0.id, let task = $0.task {
                                            return .init(id: id, task: task)
                                        }
                                        
                                        return nil
                                    })
                                }
                                
                                isWriting = false
                            }catch {
                                isWriting = false
                                print(error.localizedDescription)
                            }
                        }
                    }
                    .disabled(isWriting)
                }
            })
        }
    }
}

@Generable
struct Todo: Identifiable {
    var id: String
    @Guide(description: "칫솔질") //어떤 내용이 올지 샘플을 제공함
    var task: String
}
```
{% endraw %}




#### 3. scrollEdgeEffectStyle()


기본적으로, List, Navigation, 그리고 다른 UI 컴포넌트들은 이제 안전 영역(safe areas)에
부드러운 블러 효과(Progressive Blurs라고도 불림)를 갖습니다. 그러나 SwiftUI는 이러한 효과를
제어할 수 있는 간단한 수정자(modifier)를 제공합니다.


![3](/assets/img/2025-09-21-2️⃣ WWDC-2025--SwiftUI-7.0--iOS-26.md/3.png)



{% raw %}
```swift
import SwiftUI
import FoundationModels

struct ContentView: View {
    @State private var todos: [Todo] = []
    @State private var isWriting: Bool = false
    var body: some View {
        NavigationStack {
            List {
                ForEach(todos) { todo in
                    Text(todo.task)
                }
            }
            .navigationTitle("Todo")
            .toolbar(content: {
                ToolbarItem(placement: .topBarTrailing) {
                    Button("", systemImage: "apple.intelligence") {
                        let propmt = "Create 10 todo list items in Korean"
                        Task {
                            do {
                                let session = LanguageModelSession()
                                let response = session.streamResponse(generating: [Todo].self) {
                                    propmt
                                }
                                
                                isWriting = true
                                for try await chunkTodos in response {
                                    self.todos = chunkTodos.content.compactMap({
                                        if let id = $0.id, let task = $0.task {
                                            return .init(id: id, task: task)
                                        }
                                        
                                        return nil
                                    })
                                }
                                
                                isWriting = false
                            }catch {
                                isWriting = false
                                print(error.localizedDescription)
                            }
                        }
                    }
                    .disabled(isWriting)
                }
            })
            .scrollEdgeEffectStyle(.hard, for: .top)
        }
    }
}
```
{% endraw %}




#### **4. backgroundExtensionEffect()**


작은 이미지를 사용할 때 잠금 화면 상단에서 확장된 블러 효과가 나타나는 것을 모두 본 적이 있을 것입니다.


그런데 이제 이 기능이 SwiftUI에서 **modifier(수정자)** 로 제공됩니다!


이 수정자는 뷰를 사용 가능한 안전 영역(safe areas)까지 확장하며, 그 영역에 은은한 블러 효과를 적용합니다.


![4](/assets/img/2025-09-21-2️⃣ WWDC-2025--SwiftUI-7.0--iOS-26.md/4.png)


![5](/assets/img/2025-09-21-2️⃣ WWDC-2025--SwiftUI-7.0--iOS-26.md/5.png)



{% raw %}
```swift
import SwiftUI

struct ContentView: View {
    var body: some View {
        GeometryReader {
            let size = $0.size
            Image(.pic2)
                .resizable()
                .aspectRatio(contentMode: .fill)
                .frame(width: size.width, height: size.height)
                .clipped()
                .backgroundExtensionEffect()
        }
    }
}
```
{% endraw %}




#### 5. Rich TextEditor


마침내, TextEditor가 이제 AttributedString 을 Binding으로 지원합니다.
또한 기본 제공 TextEditor에는 몇 가지 유용한 리치 텍스트 편집 기능 옵션도 포함되어 있습니다!


![6](/assets/img/2025-09-21-2️⃣ WWDC-2025--SwiftUI-7.0--iOS-26.md/6.png)


![7](/assets/img/2025-09-21-2️⃣ WWDC-2025--SwiftUI-7.0--iOS-26.md/7.png)



{% raw %}
```swift
import SwiftUI

struct ContentView: View {
    @State private var richText = AttributedString()
    var body: some View {
        TextEditor(text: $richText)
            .frame(height: 300)
            .padding(15)
    }
}
```
{% endraw %}




#### 6. Native WebView


SwiftUI가 이제 Native WebView 를 지원합니다. 스크롤 위치 추적, 스크롤 위치 업데이트,
특정 제스처 비활성화 등 다양한 기본 내장 기능들이 포함되어 있습니다.


![8](/assets/img/2025-09-21-2️⃣ WWDC-2025--SwiftUI-7.0--iOS-26.md/8.png)



{% raw %}
```swift
import SwiftUI
import WebKit

struct ContentView: View {
    var body: some View {
        WebView(url: url)
    }
    
    var url: URL {
        URL(string: "https://developer.apple.com")!
    }
}
```
{% endraw %}




#### **7. WebPage()**


WebPage를 사용하여 페이지를 불러올 수도 있습니다. 이렇게 하면 웹 페이지를 보다 프로그래밍적으로 제어할 수 있습니다!


![9](/assets/img/2025-09-21-2️⃣ WWDC-2025--SwiftUI-7.0--iOS-26.md/9.png)



{% raw %}
```swift
import SwiftUI
import WebKit

struct ContentView: View {
    @State private var page = WebPage()
    var body: some View {
        WebView(page)
            .webViewMagnificationGestures(.disabled)
            .onAppear {
                page.load(URLRequest(url: url))
            }
    }
    
    var url: URL {
        URL(string: "https://developer.apple.com")!
    }
}
```
{% endraw %}




#### **8. TabView Customizations**


기본적으로, SwiftUI는 새로운 **iOS 26 글로시 탭 바(glossy tab bar)** 에 자동으로 적용됩니다. (단, 앱이 이전에 네이티브 탭 바를 사용했을 경우이며, 커스텀 탭 바를 사용한 경우는 제외됩니다.)


iOS 26에서는 **검색(Search) 역할의 탭 아이템**이 탭 바에서 제외되어, 탭 바와는 별도로 표시됩니다!


![10](/assets/img/2025-09-21-2️⃣ WWDC-2025--SwiftUI-7.0--iOS-26.md/10.png)


![11](/assets/img/2025-09-21-2️⃣ WWDC-2025--SwiftUI-7.0--iOS-26.md/11.png)



{% raw %}
```swift
import SwiftUI

struct ContentView: View {
    var body: some View {
        TabView {
            Tab.init("Home", systemImage: "house.fill") {
                Text("Home")
            }
            
            Tab.init("Favorite", systemImage: "suit.heart.fill") {
                Text("Favorite")
            }
            
            Tab.init("Settings", systemImage: "gearshape.fill") {
                Text("Settings")
            }
            
            Tab.init("Search", systemImage: "magnifyingglass", role: .search) {
                Text("Search")
            }
        }
    }
}
```
{% endraw %}



**+. tabViewBottomAccessory()**


iOS 26에서는 **TabView** 가 이제 탭 바 위에 액세서리 뷰를 추가하는 것을 지원합니다. 


(Apple Music 앱과 동일한 방식입니다.)


![12](/assets/img/2025-09-21-2️⃣ WWDC-2025--SwiftUI-7.0--iOS-26.md/12.png)



{% raw %}
```swift
import SwiftUI

struct ContentView: View {
    var body: some View {
        TabView {...}
        .tabViewBottomAccessory {
            Text("Custom Music Player!")
                .padding(.horizontal, 15)
            
        }
    }
}
```
{% endraw %}



**+. tabBarMinimizeBehaviour()**


Apple Music 앱과 마찬가지로, 이제 탭 바는 스크롤을 내리거나(Scrolled Down) 올릴 때(Scrolled Up) 최소화(minimizing)를 지원합니다.


스크롤을 내리거나 올리면, **검색(Search) 역할의 탭 아이템**은 오른쪽으로 이동하고, 탭 바는 최소화되어 왼쪽으로 밀립니다.


또한, 액세서리 뷰는 중앙으로 이동하게 됩니다.


![13](/assets/img/2025-09-21-2️⃣ WWDC-2025--SwiftUI-7.0--iOS-26.md/13.png)



{% raw %}
```swift
import SwiftUI

struct ContentView: View {
    var body: some View {
        TabView {
            Tab.init("Home", systemImage: "house.fill") {
                ScrollView(.vertical) {
                    Text("Home")
                        .containerRelativeFrame([.horizontal])
                        .containerRelativeFrame(.vertical) { value, _ in
                            value * 3
                        }
                }
            }
            
            Tab.init("Favorite", systemImage: "suit.heart.fill") {
                Text("Favorite")
            }
            
            Tab.init("Settings", systemImage: "gearshape.fill") {
                Text("Settings")
            }
            
            Tab.init("Search", systemImage: "magnifyingglass", role: .search) {
                Text("Search")
            }
        }
        .tabViewBottomAccessory {
            Text("Custom Music Player!")
                .padding(.horizontal, 15)
            
        }
        .tabBarMinimizeBehavior(.onScrollDown)
    }
}
```
{% endraw %}



📒 tabBarAccessoryPlacement 환경(environment)을 사용하여 탭 바 액세서리 뷰를 상황에 맞게 업데이트할 수 있습니다!



#### 9. ToolBarSpacer


기본적으로, 모든 ToolBar 아이템은 iOS 26에서 함께 그룹화됩니다.
그러나 경우에 따라 버튼을 그룹에서 분리해야 할 필요가 있을 수 있습니다.
이 새로운 modifier는 ToolBar 아이템을 분리하거나, 여러 개의 ToolBar 아이템 그룹을 만드는 데 특히 유용합니다.


![14](/assets/img/2025-09-21-2️⃣ WWDC-2025--SwiftUI-7.0--iOS-26.md/14.png)



{% raw %}
```swift
import SwiftUI

struct ContentView: View {
    var body: some View {
        NavigationStack {
            List {
                
            }
            .navigationTitle("Todo's")
            .toolbar {
                ToolbarItem(placement: .topBarTrailing) {
                    HStack {
                        Button("", systemImage: "suit.heart.fill") {
                            
                        }
                        Button("", systemImage: "magnifyingglass") {
                            
                        }
                    }
                }
                ToolbarSpacer(.fixed, placement: .topBarTrailing)
                
                ToolbarItem(placement: .topBarTrailing) {
                    Button("", systemImage: "person.fill") {
                        
                    }
                }
            }
        }
    }
}
```
{% endraw %}




#### 10. **@Animatable**


보시는 것처럼, 이 원(circle) 모양을 애니메이션화하려면, 이전에는 Shape의 모든 속성을 **animatable 프로토콜**에 맞게 구현해야 했습니다.


그러나 이 간단한 매크로만 사용하면 전체 Shape가 애니메이션화될 수 있습니다.


그런데, 만약 특정 속성에는 애니메이션이 필요하지 않다면 어떻게 할까요?


그 경우에는 해당 속성에 **@AnimatableIgnored** 매크로를 사용할 수 있습니다!


![15](/assets/img/2025-09-21-2️⃣ WWDC-2025--SwiftUI-7.0--iOS-26.md/15.png)



{% raw %}
```swift
import SwiftUI

struct ContentView: View {
    @State private var expand: Bool = false
    var body: some View {
        VStack {
            CircleShape(radius: expand ? 100 : 0)
                .contentShape(.rect)
                .onTapGesture {
                    withAnimation(.smooth) {
                        expand.toggle()
                    }
                }
        }
        .padding()
    }
}


struct CircleShape: Shape {
    var radius: CGFloat

    var animatableData: CGFloat {
        get { radius }
        set { radius = newValue }
    }

    func path(in rect: CGRect) -> Path {
        Path { path in
            path
                .addArc(
                    center: .init(x: rect.midX, y: rect.midY),
                    radius: radius,
                    startAngle: .zero,
                    endAngle: .init(degrees: 360),
                    clockwise: false)
        }
    }
}
```
{% endraw %}



+. @Animatable 사용방법 정정


View, ViewModifier 가능


Shape (이미 Animatable 프로토콜 채택됨) 사용못함



{% raw %}
```swift
import SwiftUI

// ✅ @Animatable 매크로는 View나 ViewModifier에 사용
@Animatable
struct ScaleEffect: ViewModifier {
    var scale: CGFloat
    
    func body(content: Content) -> some View {
        content
            .scaleEffect(scale)
    }
}

@Animatable
struct RotatingView: View {
    @AnimatableIgnored var rotation: Double
    
    var body: some View {
        Image(systemName: "star.fill")
            .font(.largeTitle)
            .foregroundColor(.yellow)
            .rotationEffect(.degrees(rotation))
    }
}

// ✅ 사용 예제
struct AnimatableMacroDemo: View {
    @State private var isAnimating = false
    
    var body: some View {
        VStack(spacing: 40) {
            // ViewModifier 사용
            Text("Scalable Text")
                .font(.title)
                .modifier(ScaleEffect(scale: isAnimating ? 1.5 : 1.0))
            
            // Animatable View 사용
            RotatingView(rotation: isAnimating ? 360 : 0)
            
            Button("Animate") {
                withAnimation(.easeInOut(duration: 2.0)) {
                    isAnimating.toggle()
                }
            }
            .buttonStyle(.borderedProminent)
        }
        .padding()
    }
}

// MARK: - Shape의 올바른 animatableData 구현 패턴들

// 단일 값 애니메이션
struct AnimatedLine: Shape {
    var progress: CGFloat
    
    var animatableData: CGFloat {
        get { progress }
        set { progress = newValue }
    }
    
    func path(in rect: CGRect) -> Path {
        Path { path in
            path.move(to: CGPoint(x: 0, y: rect.midY))
            path.addLine(to: CGPoint(x: rect.width * progress, y: rect.midY))
        }
    }
}

// 복수 값 애니메이션 (AnimatablePair 사용)
struct AnimatedArc: Shape {
    var startAngle: Double
    var endAngle: Double
    
    var animatableData: AnimatablePair<Double, Double> {
        get { AnimatablePair(startAngle, endAngle) }
        set {
            startAngle = newValue.first
            endAngle = newValue.second
        }
    }
    
    func path(in rect: CGRect) -> Path {
        Path { path in
            path.addArc(
                center: CGPoint(x: rect.midX, y: rect.midY),
                radius: min(rect.width, rect.height) / 2,
                startAngle: .degrees(startAngle),
                endAngle: .degrees(endAngle),
                clockwise: false
            )
        }
    }
}

// Swift 6.x + iOS 26 스타일 사용법
struct ModernAnimationDemo: View {
    @State private var progress: CGFloat = 0
    @State private var arcProgress: Double = 0
    
    var body: some View {
        VStack(spacing: 30) {
            // 진행바 애니메이션
            AnimatedLine(progress: progress)
                .stroke(.blue, lineWidth: 4)
                .frame(height: 4)
            
            // 호 애니메이션
            AnimatedArc(startAngle: 0, endAngle: arcProgress * 360)
                .stroke(.purple, lineWidth: 8)
                .frame(width: 100, height: 100)
            
            Button("Start Animation") {
                withAnimation(.easeInOut(duration: 2.0)) {
                    progress = progress == 0 ? 1.0 : 0
                    arcProgress = arcProgress == 0 ? 1.0 : 0
                }
            }
            .buttonStyle(.borderedProminent)
        }
        .padding()
    }
}
```
{% endraw %}




#### **11. drawOn & drawOff Symbol Effects**


iOS 26에는 새로운 두 가지 심볼 효과가 추가되었습니다.


이 효과는 전체 레이어 또는 심볼 단위로 **on/off** 표시를 할 수 있습니다.


이 효과는 **SF Symbols 7 Beta**에서 확인할 수 있습니다!


📒 심놀 노출시 drawOn 적용 삭제시 drawOff 를 적용해야 의도대로 나온다. 아니면 똑같은 애니메이션을 보게됨 


![16](/assets/img/2025-09-21-2️⃣ WWDC-2025--SwiftUI-7.0--iOS-26.md/16.png)



{% raw %}
```swift
import SwiftUI

struct ContentView: View {
    @State private var showButton: Bool = true
    private var drawOn: SymbolEffectTransition = SymbolEffectTransition.symbolEffect(.drawOn.individually, options: .nonRepeating)
    private var drawOff: SymbolEffectTransition = SymbolEffectTransition.symbolEffect(.drawOff.individually, options: .nonRepeating)
    
    var body: some View {
        VStack(spacing: 20) {
            VStack(spacing: 15) {
                if showButton {
                    _Image(systemName: "square.and.arrow.up")
                        .transition( showButton ? drawOn : drawOff)
                }
            }
            .frame(height: 32)
            
            Button {
                showButton.toggle()
            } label: {
                Text( showButton ? "DrawOff" : "DrawOn")
                    .font(.title)
            }
        }
        .padding()
    }
    
    private func _Image(systemName: String) -> some View {
        Image(systemName: systemName)
            .resizable()
            .scaledToFit()
            .frame(width: 32)

    }
   
}
```
{% endraw %}




#### **12. DragContainer**


DragContainer는 Item이 **Transferable** 과 **Identifiable** 프로토콜 모두를 준수하도록 요구합니다.


튜토리얼 목적상 단순히 String을 사용하고 있으므로, String이 **Identifiable 프로토콜**을 따르도록 만들어봅시다!


![17](/assets/img/2025-09-21-2️⃣ WWDC-2025--SwiftUI-7.0--iOS-26.md/17.png)



{% raw %}
```swift
import SwiftUI

struct ContentView: View {
    @State private var selectedIDs: [String] = []
    var body: some View {
        VStack(spacing: 20) {
            LazyVGrid(columns: Array(repeating: GridItem(), count: 3), spacing: 15) {
                ForEach(colorItems) { item in
                    RoundedRectangle(cornerRadius: 20)
                        .fill(item.color.gradient)
                        .frame(width: 80, height: 80)
                        .overlay {
                            if selectedIDs.contains(item.id) {
                                Image(systemName: "checkmark.circle.fill")
                                    .font(.largeTitle)
                                    .foregroundStyle(.white)
                            }
                        }
                        .onTapGesture {
                            if selectedIDs.contains(item.id) {
                                selectedIDs.removeAll { $0 == item.id }
                            } else {
                                selectedIDs.append(item.id)
                            }
                        }
                }
            }
            
            RoundedRectangle(cornerRadius: 20)
                .fill(.ultraThinMaterial)
                .overlay {
                    Text("Drop Area")
                        .font(.title2)
                        .foregroundStyle(Color.secondary)
                }
        }
        .padding(20)
    }
   
}

extension String: @retroactive Identifiable {
    public var id: String {
        return self
    }
}

struct ColorItem: Identifiable {
    var id: String = UUID().uuidString
    var color: Color
}

let colorItems: [ColorItem] = [ColorItem(color: Color.init(hex: "ff6258")),
                               ColorItem(color: Color.init(hex: "209dff")),
                               ColorItem(color: Color.init(hex: "47e161")),
                               ColorItem(color: Color.init(hex: "ff3e6b")),
                               ColorItem(color: Color.init(hex: "6fd4f9")),
                               ColorItem(color: Color.init(hex: "6967ea"))]
```
{% endraw %}




#### **draggable(containerItemID) & dragContainer()**


SwiftUI는 이제 여러 개의 아이템을 드래그 앤 드롭(drag & drop)하여 한 위치에서 다른 위치로 옮기는 것을 지원합니다!



#### **Coding Assistant**


Xcode 26에는 새로운 **코딩 어시스턴트**가 도입되었습니다.


이 어시스턴트는 코드를 수정하고, 문제 해결을 도와주며, 그 외 다양한 지원을 제공합니다.


이 기능은 **macOS 26 전용**으로 제공되며, **Xcode → Settings → Intelligence** 경로에서 활성화할 수 있습니다.


기본적으로, 어시스턴트는 **ChatGPT**를 일일 사용 제한과 함께 활용합니다.


하지만, 직접 **API 키**를 추가하여 커스터마이즈할 수도 있습니다.


소스정리


[https://github.com/langpeu](https://github.com/langpeu)


출처


Kavsoft 영상을 공부하면서 정리한 내용


[https://www.youtube.com/watch?v=jwN0o8xUdXk](https://www.youtube.com/watch?v=jwN0o8xUdXk)

